package io.vertx.it;

import io.vertx.core.Vertx;
import io.vertx.core.buffer.Buffer;
import io.vertx.core.json.JsonObject;
import io.vertx.ext.unit.Async;
import io.vertx.ext.unit.TestContext;
import io.vertx.ext.unit.junit.VertxUnitRunner;
import io.vertx.jdbcclient.JDBCConnectOptions;
import io.vertx.jdbcclient.JDBCPool;
import io.vertx.jdbcclient.JDBCPrepareOptions;
import io.vertx.sqlclient.Pool;
import io.vertx.sqlclient.PoolOptions;
import io.vertx.sqlclient.Row;
import io.vertx.sqlclient.Tuple;
import org.junit.*;
import org.junit.runner.RunWith;
import org.testcontainers.containers.GenericContainer;
import org.testcontainers.containers.wait.strategy.Wait;

import java.sql.Connection;
import java.sql.DriverManager;
import java.time.Duration;
import java.util.Arrays;
import java.util.List;

@RunWith(VertxUnitRunner.class)
public class OracleTest {

  @ClassRule
  public static final GenericContainer<?> server = new GenericContainer<>("gvenzl/oracle-free:23-slim-faststart")
    .withEnv("ORACLE_PASSWORD", "vertx")
    .withExposedPorts(1521)
    .waitingFor(Wait.forLogMessage(".*DATABASE IS READY TO USE!.*", 1))
    .withStartupTimeout(Duration.ofMinutes(5));

  private static String jdbcUrl;
  private static String username;
  private static String password;

  private Vertx vertx;

  @BeforeClass
  public static void setupDatabase() throws Exception {
    jdbcUrl = String.format("jdbc:oracle:thin:@//%s:%d/FREEPDB1", server.getHost(), server.getMappedPort(1521));
    username = "sys as sysdba";
    password = "vertx";

    // Create test table with auto-generated key support using JDBC directly
    try (Connection conn = DriverManager.getConnection(jdbcUrl, username, password)) {
      // Drop table if exists (ignore errors)
      try {
        conn.createStatement().execute("DROP TABLE test_insert_table");
      } catch (Exception ignore) {
      }

      // Create table with identity column for auto-generated keys
      conn.createStatement().execute(
        "CREATE TABLE test_insert_table (" +
          "  id NUMBER GENERATED ALWAYS AS IDENTITY(START WITH 1 INCREMENT BY 1), " +
          "  fname VARCHAR2(255), " +
          "  lname VARCHAR2(255), " +
          "  CONSTRAINT test_insert_table_pk PRIMARY KEY (id))"
      );

      // Drop blob table if exists (ignore errors)
      try {
        conn.createStatement().execute("DROP TABLE test_blob_table");
      } catch (Exception ignore) {
      }

      // Create table with BLOB column for testing batch operations with BLOBs
      conn.createStatement().execute(
              "CREATE TABLE test_blob_table (" +
                      "  id NUMBER GENERATED ALWAYS AS IDENTITY PRIMARY KEY, " +
                      "  author VARCHAR2(20), " +
                      "  book BLOB)"
      );
    }
  }

  @Before
  public void before() {
    vertx = Vertx.vertx();
  }

  @After
  public void after(TestContext should) throws Exception {
    vertx
      .close()
      .onComplete(should.asyncAssertSuccess());
  }

  protected Pool initJDBCPool() {
    final JDBCConnectOptions options = new JDBCConnectOptions()
      .setJdbcUrl(jdbcUrl)
      .setUser(username)
      .setPassword(password);
    return JDBCPool.pool(vertx, options, new PoolOptions().setMaxSize(1));
  }

  @Test
  public void testBatchWithDisabledGeneratedKeys(TestContext should) {
    final Async test = should.async();
    final Pool client = initJDBCPool();

    String sql = "INSERT INTO test_insert_table (fname, lname) VALUES (?, ?)";
    List<Tuple> batch = Arrays.asList(
      Tuple.of("alice", "wonderland"),
      Tuple.of("bob", "builder"),
      Tuple.of("charlie", "brown")
    );

    // Create prepare options with auto-generated keys disabled
    JDBCPrepareOptions options = new JDBCPrepareOptions()
      .setAutoGeneratedKeys(false);

    client
      .preparedQuery(sql, options)
      .executeBatch(batch)
      .onFailure(should::fail)
      .onSuccess(rows -> {
        should.assertNotNull(rows);
        should.assertEquals(3, rows.rowCount());
        // Verify no generated keys were returned
        should.assertNull(rows.property(JDBCPool.GENERATED_KEYS));
        client.close().onComplete(v -> test.complete());
      });
  }

  @Test
  public void testBatchWithBlobParameters(TestContext should) {
    final Async test = should.async();
    final Pool client = initJDBCPool();

    String sql = "INSERT INTO test_blob_table (author, book) VALUES (?, ?)";

    // Create batch with BLOB parameters (Buffer objects)
    List<Tuple> batch = Arrays.asList(
            Tuple.of("john", new JsonObject().put("page1", "once upon a time...").toBuffer()),
            Tuple.of("jane", new JsonObject().put("page1", "in a galaxy far away...").toBuffer()),
            Tuple.of("jack", new JsonObject().put("page1", "it was a dark and stormy night...").toBuffer())
    );

    client
            .preparedQuery(sql, new JDBCPrepareOptions().setAutoGeneratedKeys(false))
            .executeBatch(batch)
            .onFailure(should::fail)
            .onSuccess(insertResult -> {
              should.assertNotNull(insertResult);
              should.assertEquals(3, insertResult.rowCount());

              // Verify the data was inserted correctly by reading it back
              client
                      .query("SELECT id, author, book FROM test_blob_table ORDER BY id")
                      .execute()
                      .onFailure(should::fail)
                      .onSuccess(rows -> {
                        should.assertEquals(3, rows.size());
                        int count = 0;
                        for (Row row : rows) {
                          count++;
                          Buffer book = row.getBuffer("BOOK");
                          should.assertNotNull(book);
                          String author = row.getString("AUTHOR");
                          should.assertNotNull(author);
                          // Verify the content is valid JSON
                          JsonObject bookJson = book.toJsonObject();
                          should.assertNotNull(bookJson.getString("page1"));
                        }
                        should.assertEquals(3, count);
                        client.close().onComplete(v -> test.complete());
                      });
            });
  }
}
