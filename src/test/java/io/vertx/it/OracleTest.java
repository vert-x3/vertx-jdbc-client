package io.vertx.it;

import io.vertx.core.Vertx;
import io.vertx.ext.unit.Async;
import io.vertx.ext.unit.TestContext;
import io.vertx.ext.unit.junit.VertxUnitRunner;
import io.vertx.jdbcclient.JDBCConnectOptions;
import io.vertx.jdbcclient.JDBCPool;
import io.vertx.jdbcclient.JDBCPrepareOptions;
import io.vertx.sqlclient.Pool;
import io.vertx.sqlclient.PoolOptions;
import io.vertx.sqlclient.Tuple;
import org.junit.*;
import org.junit.runner.RunWith;
import org.testcontainers.containers.GenericContainer;
import org.testcontainers.containers.wait.strategy.Wait;

import java.sql.Connection;
import java.sql.DriverManager;
import java.time.Duration;
import java.util.Arrays;
import java.util.List;

@RunWith(VertxUnitRunner.class)
public class OracleTest {

  @ClassRule
  public static final GenericContainer<?> server = new GenericContainer<>("gvenzl/oracle-free:23-slim-faststart")
    .withEnv("ORACLE_PASSWORD", "vertx")
    .withExposedPorts(1521)
    .waitingFor(Wait.forLogMessage(".*DATABASE IS READY TO USE!.*", 1))
    .withStartupTimeout(Duration.ofMinutes(5));

  private static String jdbcUrl;
  private static String username;
  private static String password;

  private Vertx vertx;

  @BeforeClass
  public static void setupDatabase() throws Exception {
    jdbcUrl = String.format("jdbc:oracle:thin:@//%s:%d/FREEPDB1", server.getHost(), server.getMappedPort(1521));
    username = "sys as sysdba";
    password = "vertx";

    // Create test table with auto-generated key support using JDBC directly
    try (Connection conn = DriverManager.getConnection(jdbcUrl, username, password)) {
      // Drop table if exists (ignore errors)
      try {
        conn.createStatement().execute("DROP TABLE test_insert_table");
      } catch (Exception ignore) {
      }

      // Create table with identity column for auto-generated keys
      conn.createStatement().execute(
        "CREATE TABLE test_insert_table (" +
          "  id NUMBER GENERATED ALWAYS AS IDENTITY(START WITH 1 INCREMENT BY 1), " +
          "  fname VARCHAR2(255), " +
          "  lname VARCHAR2(255), " +
          "  CONSTRAINT test_insert_table_pk PRIMARY KEY (id))"
      );
    }
  }

  @Before
  public void before() {
    vertx = Vertx.vertx();
  }

  @After
  public void after(TestContext should) throws Exception {
    vertx
      .close()
      .onComplete(should.asyncAssertSuccess());
  }

  protected Pool initJDBCPool() {
    final JDBCConnectOptions options = new JDBCConnectOptions()
      .setJdbcUrl(jdbcUrl)
      .setUser(username)
      .setPassword(password);
    return JDBCPool.pool(vertx, options, new PoolOptions().setMaxSize(1));
  }

  @Test
  public void testBatchWithDisabledGeneratedKeys(TestContext should) {
    final Async test = should.async();
    final Pool client = initJDBCPool();

    String sql = "INSERT INTO test_insert_table (fname, lname) VALUES (?, ?)";
    List<Tuple> batch = Arrays.asList(
      Tuple.of("alice", "wonderland"),
      Tuple.of("bob", "builder"),
      Tuple.of("charlie", "brown")
    );

    // Create prepare options with auto-generated keys disabled
    JDBCPrepareOptions options = new JDBCPrepareOptions()
      .setAutoGeneratedKeys(false);

    client
      .preparedQuery(sql, options)
      .executeBatch(batch)
      .onFailure(should::fail)
      .onSuccess(rows -> {
        should.assertNotNull(rows);
        should.assertEquals(3, rows.rowCount());
        // Verify no generated keys were returned
        should.assertNull(rows.property(JDBCPool.GENERATED_KEYS));
        client.close().onComplete(v -> test.complete());
      });
  }
}
